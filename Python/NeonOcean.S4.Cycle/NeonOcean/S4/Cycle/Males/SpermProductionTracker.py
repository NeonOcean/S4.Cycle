from __future__ import annotations

import random

from NeonOcean.S4.Cycle import Events as CycleEvents, Guides as CycleGuides, ReproductionShared, This
from NeonOcean.S4.Cycle.Males import Shared as MalesShared, Sperm
from NeonOcean.S4.Main import Debug
from NeonOcean.S4.Main.Tools import Classes, Events, Exceptions, Python, Savable, Types
from sims import sim_info

class SpermProductionTracker(ReproductionShared.TrackerBase):
	def __init__ (self, trackingSystem: ReproductionShared.ReproductiveSystem):
		super().__init__(trackingSystem)

		self.SpermGeneratingEvent = Events.EventHandler()

		self.SpermGeneratingEvent += self._SpermGeneratingCallback

		self._spermObjectsGenerated = 0  # type: int

		self.RegisterSavableAttribute(Savable.StandardAttributeHandler("SpermObjectsGenerated", "_spermObjectsGenerated", self.SpermObjectsGenerated, requiredSuccess = False))

	# noinspection PyMethodParameters
	@Classes.ClassProperty
	def TypeIdentifier (cls) -> str:
		"""
		This tracker type's identifier, this is used to save and load the tracker. Loading will not be possible unless the tracker type is registered
		through the function in the reproductive trackers module.
		"""

		return MalesShared.SpermProductionTrackerIdentifier

	@property
	def SpermGeneratingEvent (self) -> Events.EventHandler:
		"""
		An event that will be triggered when a sperm object needs to be created.
		The event arguments parameter should be a 'SpermGeneratingArguments' object.
		"""

		return self._spermGeneratingEvent

	@SpermGeneratingEvent.setter
	def SpermGeneratingEvent (self, value: Events.EventHandler) -> None:
		if not isinstance(value, Events.EventHandler):
			raise Exceptions.IncorrectTypeException(value, "SpermGeneratingEvent", (Events.EventHandler,))

		self._spermGeneratingEvent = value

	@property
	def SpermObjectsGenerated (self) -> int:
		"""
		The total number of sperm objects that have been generated by this sperm production tracker.
		"""

		return self._spermObjectsGenerated

	@classmethod
	def ShouldHave (cls, targetSimInfo: sim_info.SimInfo, targetSystem: ReproductionShared.ReproductiveSystem) -> bool:
		"""
		Get whether or not the target should have this tracker.
		"""

		return MalesShared.ShouldHaveMaleTrackers(targetSimInfo)

	def GenerateSperm (self) -> Sperm.Sperm:
		"""
		Create an sperm object based off and made for this reproductive system.
		"""

		generationSeed = self.TrackingSystem.CurrentSeed  # type: int

		random.seed(self.SpermObjectsGenerated)
		generationSeed += random.randint(-1000000000, 1000000000)

		sperm = Sperm.Sperm()
		spermGuide = sperm.GetSpermGuide(self.TrackingSystem)  # type: CycleGuides.SpermGuide
		eventArguments = CycleEvents.SpermGeneratingArguments(generationSeed, sperm, spermGuide)

		for spermGeneratingCallback in self.SpermGeneratingEvent:
			try:
				spermGeneratingCallback(self, eventArguments)
			except:
				Debug.Log("Failed to call sperm generating callback '" + Types.GetFullName(spermGeneratingCallback) + "'.\n" + self.TrackingSystem.DebugInformation,
						  This.Mod.Namespace, Debug.LogLevels.Exception, group = This.Mod.Namespace, owner = __name__, lockIdentifier = __name__ + ":" + str(Python.GetLineNumber()), lockReference = spermGeneratingCallback)

		sperm.Generate(eventArguments)

		self._spermObjectsGenerated += 1

		return sperm

	def _GetNextReproductiveTimeMultiplier (self) -> float:
		return MalesShared.GetSpermProductionTrackerReproductiveTimeMultiplier()

	# noinspection PyUnusedLocal
	def _SpermGeneratingCallback (self, owner: ReproductionShared.TrackerBase, eventArguments: CycleEvents.SpermGeneratingArguments) -> None:
		eventArguments.Source = self.TrackingSystem.SimInfo
